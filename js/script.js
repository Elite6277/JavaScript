"use strict"

//? Функции конструкторы

// Про классификации типов данных мы помним что функция по своей сути является объеком и по идее в нее можно записать какие то методы и свойства .
//Так же в самом начале своего пути  существует длинный синтаксис для создания типов данных которая начинается с ключевого слова new 

// Создаем новое число 
const num = new Number(3);
console.log(num);

//  Создаем новую функцию
// Если такая функция будет содержать методы и свойства она в итоге создаст нам новый объект
// Тоесть созданием новой функции мы с вами создаем новый объект свойства которого уже прописаны в этой функции

const num = new Function(3);
console.log(num);

// Теперь нормальеый пример без устаревшего синтаксиса

// Такие функции у нас предназначены для конструирования объектов и создания множества подобных копий
// По факту это такой прототип от которого мы постоянно можем отпачковывать определенных потомков mercedes lada skoda и прочее все они чем то различаются но в общем они похожи точно также мы можем передавать туда аргументы по типу двигателя колес и различных запчастей но в общем у них остается один и тот же смысл
// В таких функция нам не нужен return мы нечего не возвращем 
function User(name, id) {
   // Теперь когды мы сипользовали такой синтаксис наша функция стала конструктором
   // С ее помошью теперь мы можем создавать новых пользователей
   // Кроме свойств как и в обычном объекте мы можем написать и какие то методы
   this.name = name;
   this.id = id;
   this.human = true;
   this.hello = function () { // создав один раз метод прямо  в нашем прототипе он будет у каждого из наших потомков
      console.log(`Hello ${this.name}`);// мы можем уже использовать те свойства которые находятся прямо в объекте 
   };
}

//this для каждого отдельного пользователя

// При помощи свойтва  prototype мы можем добавлять новые методы или свойства в наш конструктор и они будут прототипно наследоваться у потомков
// Этот прием используется когда у нас нет доступа к нашему прототипу мы его не можем менять по каким то причинам но его нужно немноко модифицировать тоесть добавить каких то плюшек

// Теперь  у нас прототипно уже будет наследоваться и этот метод
// И он появиться у всех потомков которые были созданы после  объявления этого метода;
User.prototype.exit = function () {
   console.log(`Пользователь ${this.name} ушел`);
}



const medet = new User('Medet', 28); // Внутри этой переменной у нас  будет находится уже не функция а объект 
//потому что функция user у нас стала конструктором и теперь когда она вызывается с помошью ключеового слова  new  она создает новый объект с тесми свойствами которые мы записали
const alex = new User('Alex', 20);

// Заметье что мы указываем не прототип  как это было в setPrototype когда одно наследуеться от другого а просто добавляем новые свойства либо методы в уже существующий наш объект

medet.exit();

medet.hello();
alex.hello();

console.log(medet);
console.log(alex);

// Конструкторы нам необходимы для создания новых однотипных объектов
// в практике это могут быть новые пользователи сайта товары в магазинах ролики на ютубе везде где есть шаблонизация причем даже компоненты сайтов могут создаваться таким образом

//!Важный момент
// Все что выше мы разбирали стандарты ES5 это то как на самом деле происходит под капотом JS его внутренности
// В стандарте ES6 у нас появились классы 
// Классы это так называемые синтактический сахар, тоесть красивая обертка всего функционала которая существует внутри
// Классы удобнее использовать поэтому весь реальный функцонал прямо сейчас создается именно с использованием классов
// Если спросять можно ответить что в JS классов изначально не было классов они появились уже в качестве синтактического сахара

//Пример содания классов 

class User {
   constructor(name, id) {
      this.name = name;
      this.id = id;
      this.human = true;
   }
   hello() {
      console.log(`Hello ${this.name}`);
   }
   exit() {
      console.log(`Пользователь ${this.name} ушел`);
   }
}