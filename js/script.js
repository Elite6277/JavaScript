"use strict"

// Контекст вызова this. функции

// Это то что окружает функцию  и в каких случаях она вызывается
// Контекст это самая сложная тема в JavaScripte для понимания новичков

// Функция может вызываться четыремя спсобами и в каждом контекст вызова отличается

// Первый метод это просто вызов нашей функции
// Если мы запускаем объект таким образом и используем в нем контекст то без 'use strict' этот контекст будет ссылаться на глобальный объект window 
// А с use strict  вернется undefined

//function showThis(a, b) {
//   console.log(this);
//   function sum() { // Эта функция в начале ищет аргументы внутри себя а потом если не находит обращается к родительской функции
// Здесь испоьзутся замыкание функции это когда функция вызывается внутри себя
//      console.log(this);
//      return a + b
//   }
//   console.log(sum());
//}
//showThis(4, 5);
// Даже если у нас используется функция внутри функции констекс у нее не меняется он все равно буде или window или undefined 

//const obj = {
//   a: 20,
//   b: 20,
//   sum: function () {
//      function shout() {
//         console.log(this);
//      }
// Эту же функцию мы вызываем внутри этого же метода
// Мы сейчас смотрим контекст вызова  функции shout(); мы получим undefined потому что это простой вызов функции он уже не относится к методу это не метод объекта это функция которая запускается внутри  метода поэтому контекст вызова она просто потеряла
//      shout();
//   }
//};

//obj.sum();


// Функция коснструктор когда она будет вызвана она у нас создаст новый объект
//function User(name, id) {
// Здесь мы с вами прописывали свойства которые обращаются к this
// Самое главное мы чтобы записать какое то свойство обращаемся к чему к какому то объкту и это действительно будет объект
//   this.name = name;
//   this.id = id;
//   this.human = true;
//}

// this всегда ссылается на вот этот экземпляр который создан и вместо thhis мы подставляем новый объект User мы записываем ему новые свойства тоесть вместо this мы подставляем новый объект  и в это свойсто name мы передаем то значение которое передали при создании этого объекта
// Даже если у нас появятся какие то методы внутри  этого прототипа функции коснтрукторы  ссылвется на name при создании b сыылается на заданное уже значения свойсто name

//let medet = new User('Ivan', 23);



// Ручное присвоение this каждой функции
function sayName(surname) {
   console.log(this);
   console.log(this.name + surname);
}

// Самая главная задача как сделать так чтобы функция sayName когда запускалась  она была как контекст не window или undefined а именно user чтобы мы могли получить доступ к этому name
// Для этого у нас сущ два метода это call и apply

// Во внутрь call мы передаем контекст вызова который мы хотим передать в эту функцию точно также и apple 
// Эти функции делают одно и тоже  разницы в функциональности нет разница только в синтаксисе
// Функция преобрела свой контекст благодаря тому что мы использовали  два метода мы четко сказали эй функция заработай на вот этом вот объекте и используй его данные так что теперь мы можем гибко контролировать контекст вызова

//

const user = {
   name: 'John'
}

// В call аргументы передаются через запятую и в виде строки
// Здесь мы функцию новую не вызывали мы просто контекст установили
sayName.call(user, ' Smith');
// В apply аргументы передаются в массиве
sayName.apply(user, [' Smith']);

// Классический пример функция удваивания
function count(num) {
   return this * num;
}
//в эту переменную мы помещаем новую функцию
const double = count.bind(2); // двойка у нас переходит наверх вместо this и она будет предаваться в функцию double

// Мы понимаем что double это новая функция у которой есть жестко привязанный контекст
// Теперь мы в double можем передавать только один аргумент который будет удваиваться 
// Тоесть мы навсегда забиндили такую функцию
//! Этот метод будет очень часто встречатся особенно при работе с продвинутыми вещами  типо React
console.log(double(3));
console.log(double(13));


// band создает новую функцию связанную с этим объектом

// 1) Обычная фуннкция: this =window, но если use strict - undefined
// 2) Методы объектов это тоже функции  Контекст у методов объекта это = сам объект
//!3) this в конструкторах и классах - это новый экземпляр объекта нужно выучить наизусть потому что на нем будет строится огромное кол-во интерактива в будущем  какую  библиотеку в будущем не будете использовать это React, Angular, Vue  каждый раз вы будете сталкиватся вот с таким поведением this 
// 4) Ручная привязка this: call '', apply[''] bind() 


const btn = document.querySelector('button');

// Создаем не стрелочную а обычную callback функцию

// Когда у нас обработчик событий написан как callback функция написан в классическом режиме то констекс вызова будет сам элемент на котором произошло событие
// Почти всегда this здесь будет равнятся тоже самое что и event.target
//! Важное правило В обработчиках событий когды мы используем обычную функцию мы имеем доступ к this это тоже самое что и event.target
//! Если же мы используем стрелочную функцию то this уже будет равен с use strict undefined или   ссылаться на window без use strict
btn.addEventListener('click', function () {
   // В данном случае контекстом вызова у нас будет сам элемент в котором произошло событие но так рабоатет не всегда
   console.log(this);
   // Чаще всего в практике используется именно объект события а не констекст вызова
   this.style.backgroundColor = 'red';
});

// Но чаще всего при сипользовании обработчиков события мы будем использовать event.target  в стрелочных функциях 
btn.addEventListener('click', (e) => {
   // В данном случае контекстом вызова у нас будет сам элемент в котором произошло событие но так рабоатет не всегда
   console.log(this);
   // Чаще всего в практике используется именно объект события а не констекст вызова
   e.style.backgroundColor = 'red';
});
// Работа стрелочной функции с контекстом вызова
//! Фишка стрелочной функции Дело в том что у стрелочной функции нет своего констекста вызова она всегда его будет  брать  у своего родителя
// 

const obj = {
   num: 5,
   // у метода всегда контекст ссылается на объект в котором он существует
   sayNumber: function () {
      const say = () => {
         // This в этом случае будет ссылаться на сам объект потому что он берет контекст своего родителя
         console.log(this.num);
      };
      say();
   }
}

// Если говорить у стрелочных функциях они часто используются для модификации каких то элементов прямо здесь на месте
obj.sayNumber();

// если мы пишем стрелочную функцию вот таким образом в одну строчку то ключевое слово return нам ставить нужно оно подставиться автоматически
// Стрелочная функция если она использует только один аргумент  то аргумент можно записать без скобок
const doublex = a => a * 2;

console.log(doublex(4))