"use strict"

//Promise(ES6) - Обещания 

//Без этой технологии сейчас frontend трудно представить и она позволяет нам довольно успешно работать с различными ассинхронными операциями 
// Ассинхронный код бывает у нас например: в таймаутах когда мы запускаем что какая то функция выполнится через определенный промежуток времени либо будет повторятся через определенный промежуток либо при запросах на сервер когда мы точно не знаем через сколько ответит нам сервер и у нас операция идет ассинхронно 

// мы говорим если произошло что то то мы обещаем что у нас выполнится следующее действие 
//Здесь есть четкая цеочка действий которая зависит от предыдущих результатов Мы можем выполнить следующее действие только если предыдущий вариант наших действий был  успешно выполнен

console.log('Запрос данных...');

//!НЕВЕРОЯТНО ВАЖНАЯ ТЕМА В JavaScript
// Создание promise

// Обычно когда мы создаем промисы эта callback функция принимает у нас два аргумента это resolve, reject

// Создаем обещание которое помещаем во внутрь переменной req
// Когда мы создаем обещание promise мы предпологаем  что оно может завершиться как положительно так и отрицательно  но в данный момент мы не знаем как оно завершится  у нас есть определенный промежуток времени до того как мы получим результат тоже самое как это происходит у нас с сервером мы посылаем запрос на сервер и ждем ответа  от него мы не знаем как нам ответит сервер положительно или отрицательно 
//внутри этого Промиса есть два атрибута resolve и reject по факту это аргументы вместо которых будут подставлятся функции если у нас все пошло правильно все хорошо отработало сервер нам ответил то мы будем вызывать функцию resolve
//Если вдруг что то пошло не так вызываем reject 
const req = new Promise((resolve, reject) => {//здесь когда мы используем промисы у нас эти два аргумента обозночают функции которые мы в будущем можем сами передавать 
   // resolve значит что что то выполнилось правильно обещание выполнилось
   // reject обещание не выполнилось и у нас что то пошло не так

   // Здесь у нас идет имитация ассинхронного кода допустим мы сделали запрос на наш сервер 
   setTimeout(() => { // запускаем setTimeOut()
      console.log('Подготовка данных'); //говорим чтобы сервер нам вернул вот такое сообщение
      const product = {// и такие данные
         name: 'TV',
         price: 2000
      };
      // И  эти данные получаем значит все в порядке и значит мы должны вызвать функцию resolve которая у нас говорит что все ок наше обещание выполнилось в положительную сторону  и это все произойдет у нас через две секунды 

      // Дальше  когда мы начинаем использовать эти промисы мы должны обработать все эти варианты как  resolve так и reject 

      //ему передаем данные которые будут идти дальше
      resolve(product);
   }, 2000)
});
// Для того чтобы обрабатывать положительный результат  унас есть метод который наз-ся then() он внутри себя принимает тот аргумент с функцией который называется resolve
// then() этот метод который выполняется на промисе в случаи положительного исхода 
// Функция resolve эта нижняя  будет принимать в качестве аргумента  product который нам вернулся из предыдущего этапа
req.then((product) => {
   return new Promise((resolve, reject) => {
      setTimeout(() => {
         product.status = 'order';
         resolve(product);
      }, 2000);
   });
}).then(data => {
   data.modify = true;
   return data;
}).then(data => {
   console.log(data);
}).catch(() => {// Это действие выполнится при какой то ошибке если сверху что то пойдет не так
   console.error('Произошла ошибка')
}).finally(() => {
   console.log('Finally ')
});
// Эту часть мы можем заменить функцией resolve
// У Promise есть огромное преимущество перед callbackами мы можем возвращать promise и then по цепочке когда одна асинхронная оперция выполнится мы выполним следующую и тому подобное  
// Reject мы можем получить когда ссылаемся на не существующий сервер не сущ файл или сервер упал и все эти операци  мы можем обработать при помощи reject  
// Чтобы обработать ошибку у нас есть специальный блок кода который наз-ся cathc обычно catch ставиться в конце привыкайте к этому 

//Блок кода finally является важной частью promise и он используется всегда в конце после всех взаимодействий и обработок ошибок  он позволяет выполнить нам действия в абсолютно любом исходе promisa тоесть это действия которые должны быть воспроизведены абсолютно всегда 




// Такие функции можно использовать чтобы запускать одинаковые операци через определенный промежуток времени 
const test = time => {
   return new Promise(resolve => {
      setTimeout(() => resolve(), time);
   });
};

//test(1000).then(() => console.log('1000 ms'));
//test(1000).then(() => console.log('2000 ms'));

// Команда Promise.all служит для того чтобы мы точно убедились в том что все наши promise уже выполнились 
// Если говорить о практике  то мы можем например делать несколько заросов на разные сервера чтобы получить определенные изображения  и эти сервера по разному отвечают нам с разным промежутком времени но при всем этом мы хотим чтобы на сайте у нас использовались все 3 или 4 изображения сразу как только они все загрузятся тоесть мы должны подождать загрузки всех наших промисов  и только потом что то делать как раз Promise.all этим и занимается

//Promise.all ждет окончания всех promisoв которые были переданы сюда в массив и только потом  он что то будет выполнять и для того чтобы что то выполнить мы можем использовать  then если положительно все прошло  либо catch написать что какой то из промисов у нас не выполнился и какой то внутри сломался 
//Promise all ждет выполнения всех promise и толко тогда что то делал 
Promise.all([test(1000), test(2000)]).then(() => {
   console.log('all');
});

// Promise.race() выполняет свои дейсвия только когда самый первый promise у нас правильно  отработал
Promise.race([test(1000), test(2000)]).then(() => {
   console.log('all');
});

// Второй метод называется race и переводится как гонка  и он делает почти обратную ситуацию

