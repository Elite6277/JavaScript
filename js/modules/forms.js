function forms() {
   // Forms
   // Реализация скрипта отправки данных на сервер


   // Получаем все формы по тегу форм
   const forms = document.querySelectorAll('form');
   // Этот объект будет содержать список всех фраз которые я буду показывать в различных ситуациях 
   const message = {
      //Чтобы использовать изображение из проекта необходимо лишь использовать пути к этим картинкам
      loading: 'img/form/spinner.svg',
      success: 'Спасибо скоро мы с вами свяжемся',
      failure: 'Что-то пошло не так...',
   }

   //! Важный момент когда работаем на локальном сервере скорее всего после изменений каких то сбрасывать кэш, делается это для того чтобы изменения применились на странице потому что сервер запоминает старые изменения  чтобы каждый раз не подгружать и это наз-ся кэшом чтобы сбросит кэш Shift f5  

   //Самое главное это взять все наши формы и под кажду из них подвязать postData подвязать 

   forms.forEach(item => {
      //Сейчас на каждую форму будет подвязана функция postData который будет обработчиком события при отправке
      bindPostData(item);
   });

   //Самое главное это взять все наши формы и под кажду из них подвязать postData подвязать 

   //Сейчас на каждую форму будет подвязана функция postData который будет обработчиком события при отправке
   //Cоздаем функцию function Expression 

   // Наша функция postData занимается тем что она настраивает наш запрос она fetchit тоесть посылает наш запрос на сервер получает какой то ответ от сервера что например запостили успешно и после этого транформирует этот ответ в Json
   const postData = async (url, data) => {
      // создаем переменнную result  во внутрь нее мы  с вами будем помешать промис который возврашается от fetch 
      //когда мы делаем запрос мы сразу можем обработать те данные которые пришли 

      //она fetchit
      const res = await fetch(url, {// это асинхронный код и он не ждет другой код  и Нам нужен механизм который превращяет ассинхронный код в синхронный для решения этой проблемы  появились такие операторы как Assync Await  
         //await значит что неоьходимо дождаться результата этого запроса какой результат нас не волнует самое главное что мы должны его дождаться и толкьо после того как у нас будет результат await пропустит нас дальше 
         method: 'POST', //каким образом  
         headers: {
            'Content-type': 'application/json'
         },
         // и что имеено
         body: data
      });
      //транформирует этот ответ в Json
      return await res.json(); // Пишем здесь return чтобы могли дальше по цепочке обработать и тут  мы должны дождатся результата этого промиса прежде чем его returnit
   }

   // Функция которая будет отвечать за постинг даных
   function bindPostData(form) {// эта функция будет принимать в себя какую то форму 
      // Используем аргумент форм потому что нам удобно бцдет навесить обработчик события
      form.addEventListener('submit', (e) => { // и будем мы использовать событие submit оно срабатывает каждый раз когда мы пытаемся отправить какую то форму
         //Чтобы отменить стандартное поведение браузера мы используем e.preventDefault
         // Именно эта команда должна идти в самом начале чтобы не было проблем
         e.preventDefault();

         // Очень частый прием это создание нового блока на странице и туда мы выводим сообщение картинку не важно что самое главное что динамически будет появлятся какой то блок и чаще всего он добавляется к форме 

         //создаем div
         const statusMessage = document.createElement('img');

         //Добавляем классы в div 
         statusMessage.src = message.loading;
         // Берем элемент и во внутрь помещаем то сообщение которое мы хотим показать 

         // Как только мы отправляем запрос  как только у нас произошел submit у нас самое главное сообщение это загрузка мы скажем пользователю что произошла загрузка  если у него медленный интернет он увидет это сообщение
         statusMessage.style.cssText = `
            display:block;
            margin: 0 auto;
         `;
         // Главное не забыть отправить наш statusMessage куда то на страницу ведь  пока что он сущ лишь в JavaScripte 
         // form.append(statusMessage);

         // Этот метод позволяет нам помещать наши элементы в разные места нашей верстки 
         form.insertAdjacentElement('afterend', statusMessage)
         // Вместо XMLHttpReques работаем с fetch 

         //После этого Работаем с методом XMLHttpRequest() 
         //const request = new XMLHttpRequest();
         // После этого  унас всегда вызывается метод open() чтобы настроить этот запрос
         //request.open('POST', 'server.php');
         // Следующая самая главная самая важная задача сделать так чтобы все данные которые заполнил пользователь в форме мы получили в JavaScripte и уже могли отправить на сервер
         // Самый простой способ подготовить такие данные сформы это использовать объект который наз-ся formData 
         //нам не всегда нужно передавать в формате JSON
         // Есть два формата первый это FormData второй это когда мы передаем JSON

         // formData это специальный объект который позволяет с определенной формой быстро сформировать  все данные которые заполнил пользователь 
         //во внутрь мы помещаем форму из которой нам нужно собрать данные

         //!Очень важный момент на котором можно запнуться и потерять много часов времени это касается того как сверстаны формы и как прописаны input если мы предпологаем что данные должны идти на сервер то в вертске внутри input всегда нужен атрибут "name" и главное чтобы знаения name они не повторялись и наче formData не сможет найти этот input не сможеть  взять из него данные value чтобы сформировать из него правтльный ответ
         //! Всегда проверяйте name  у ваших form

         //Настраиваем заголовки которые должны будут говорить серверу что именно приходит 
         // Чтобы правильно работать с FormData  во втром аргументе нам нужно указать multipart/form-data
         //!Когда мы используем  свзяку XMLHttpRequest + form-data нам заголовок устанавливать не нужно  он утстанваливается автомотически  именно иза этой проблемы на сервере мы не получим данные
         //request.setRequestHeader('Content-type', 'multipart/form-data');

         //С каким форматом  мы будем общаться  JSON или form-data  зависит от бэкенда  
         //request.setRequestHeader('Content-type', 'application/json');

         //Задача у нас есть объект FormData которую на необходимо превратить в формат JSON
         const formData = new FormData(form);

         //FormData это довольно специфический объект и мы просто так его не можем прогнать в другой формат 
         // Для этого нам понадобиться прием который частенько используется
         // Берем нашу formData которая собрала все данные с формы   ее сначала превращяеи в массив массивов после этого мы превращяем ее в классический объект а после этого мы этот классический объект превращяем в JSON 
         const json = JSON.stringify(Object.fromEntries(formData.entries())); // Метод entries возвращяет массив собственных перечисляемых свойтств у указанного объекта  массив массивов
         // Теперь когда мы получили обычный объект а не FormData() мы на нем уже можем использовать конвертацию в JSON 
         //для этого создаем промежуточную переменнную используем JSON.stringify(внутрь помещаем object)которая превращает обычный объект в JSON  
         //теперь все что надо сделать это взять JSON и поместить его в request.send(dvctnj formData json)
         //const json = JSON.stringify(object);

         // Отправляем данные используем метод send()
         //request.send(json);//здесь уже есть body потому что мы что то отправляем
         // Если внутри fetch promise попадает на ошибку котрая связана с http протоколом типо 404 502 тоесть мы сделали ошибку в названии url и тд он не выкинет reject это для него не считается ошибкой он нормально выполнит при этом reslolve самое главное для fetch  это то что он вообще смог сделать этот запрос и соответсвенно у нас reject будет возникать при сбое сети или если что то там помешало запросу  вообще выполнится у этого механизма есть свои плюсы мы еще разберем как обходить эту проблему и как выкидывать reject  даже если вдруг у нас что то пошло нет так 

         postData('http://localhost:3000/requests', json)
            .then(data => {
               console.log(data);//Data это просто те данные которые нам возврашяются из promise те которые нам вернул сервер  1 просто выведем в консоль то что нам вернул сервер 
               showThanksModal(message.success);//2  Запускаем функцию showThanksModal 
               form.reset(); // Мы сейчас поработаем и переместим ее кое куда в другое место 
               statusMessage.remove(); // Мы наш спиннер просто берем и удаляем, по факту это все действия которые нам сейчас нужны ,но если нам в будущем понадобиться в будущем еще расширить цепочку мы опять пропишем then  и выполним какую то операцию которая должна будет следовать строго за верхними командами 

            }).catch(() => {// Его желательно всегда прописывать в реальных проектах потому что нам все таки ошибки нужно обрабатывать
               //Выполняем операцию которая соответсвует ошибке 
               // Если в результате моего запроса моего fetch возникнет какая то критическая ошибка например не туда послал запрос и тому подобное то у меня в методе catch выведется функция showThanksModal(message.failure); что то пошло не так и пожалуйста повторите немножко позже  
               showThanksModal(message.failure);
            }).finally(() => {//Используем его потому что у нас есть действие которое должно выполнится всегда у нас это очистка формы 

            })
         // Когда данные уйдут на сервер нам с ними нужно будет что то сделать
         // Отслеживаем конечную загрузку запроса
         //request.addEventListener('load', () => {
         // Если все правильно произошло 
         //   if (request.status === 200) {
         //эта команда чтобы четко увидеть что все правильно произошло
         //      console.log(request.response);
         //Когда все успешно пришло выводим success тоесть у нас загрузка поменяется на success
         //      showThanksModal(message.success);
         //Очищаем нашу форму после успешной отправки 
         //      form.reset();
         //      statusMessage.remove();
         //   } else {
         //      showThanksModal(message.failure);
         //   }
         //});
      });
   }
   // Красивое оповещение пользователя
   // функция которая тоже относиться к отправке формы
   function showThanksModal(message) {
      const prevModalDialog = document.querySelector('.modal__dialog');

      prevModalDialog.classList.add('hide');
      openModal();

      const thanksModal = document.createElement('div');

      thanksModal.classList.add('modal__dialog');
      thanksModal.innerHTML = `
         <div class="modal__content">
               <div class="modal__close" data-close>×</div>
               <div class="modal__title">${message}</div>
         </div>
      `;

      document.querySelector('.modal').append(thanksModal);
      setTimeout(() => {
         thanksModal.remove();
         prevModalDialog.classList.add('show');
         prevModalDialog.classList.remove('hide');
         closeModal();
      }, 4000);

   }
}

module.exports = forms;