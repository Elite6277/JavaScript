{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU,MAAM,SAAS;AACnD,iDAAiD,WAAW;AAC5D,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI,YAAY,WAAW;AACvE;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kCAAkC;AAC3D;AACA,UAAU;AACV,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,gCAAgC;AAChC;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,iCAAiC;AACjC,gDAAgD;AAChD,6BAA6B;AAC7B,uCAAuC;AACvC;AACA,aAAa,eAAe;AAC5B;AACA,gOAAgO;AAChO;AACA,aAAa,iBAAiB;AAC9B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,YAAY;AACZ,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C,gCAAgC,WAAW;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA,QAAQ;AACR;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,yBAAyB;AACzB;AACA,QAAQ;AACR;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA,sCAAsC,WAAW;AACjD,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP,IAAI;AACJ;AACA;AACA;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UC3HA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBY;;AAEZ;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,4CAAgB;AACxC,cAAc,mBAAO,CAAC,8CAAiB;AACvC,cAAc,mBAAO,CAAC,8CAAiB;AACvC,cAAc,mBAAO,CAAC,8CAAiB;AACvC,aAAa,mBAAO,CAAC,4CAAgB;AACrC,cAAc,mBAAO,CAAC,8CAAiB;AACvC,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack:///./js/modules/calc.js","webpack:///./js/modules/cards.js","webpack:///./js/modules/forms.js","webpack:///./js/modules/modal.js","webpack:///./js/modules/slider.js","webpack:///./js/modules/tabs.js","webpack:///./js/modules/timer.js","webpack:///webpack/bootstrap","webpack:///./js/script.js"],"sourcesContent":["function calc() {\r\n   // Calc\r\n\r\n   const result = document.querySelector('.calculating__result span');\r\n\r\n   let sex, height, weight, age, ratio;\r\n\r\n   if (localStorage.getItem('sex')) {\r\n      sex = localStorage.getItem('sex');\r\n   } else {\r\n      sex = 'female';\r\n      localStorage.setItem('sex', 'female');\r\n   }\r\n\r\n   if (localStorage.getItem('ratio')) {\r\n      ratio = localStorage.getItem('ratio');\r\n   } else {\r\n      ratio = 1.375;\r\n      localStorage.setItem('ratio', 1.375);\r\n   }\r\n\r\n   function initialLocalSettings(selector, activeClass) {\r\n      const elements = document.querySelectorAll(selector);\r\n\r\n      elements.forEach(elem => {\r\n         elem.classList.remove(activeClass);\r\n         if (elem.getAttribute('id') === localStorage.getItem('sex')) {\r\n            elem.classList.add(activeClass);\r\n         }\r\n         if (elem.getAttribute('data-ratio') == localStorage.getItem('ratio')) {\r\n            elem.classList.add(activeClass);\r\n         }\r\n      });\r\n   }\r\n\r\n   initialLocalSettings('#gender div', 'calculating__choose-item_active');\r\n   initialLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n   function calcTotal() {\r\n      if (!sex || !height || !weight || !age || !ratio) {\r\n         result.textContent = '____';\r\n         return;\r\n      }\r\n      if (sex === 'female') {\r\n         // Эта формул а расчитывает суточную норму калорий для женщин\r\n         result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);\r\n      } else {\r\n         // Эта формула расчитывает суточную норму калорий для мужчин\r\n         result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);\r\n      }\r\n   }\r\n\r\n   calcTotal();\r\n\r\n   function getStaticInformation(selector, activeClass) {\r\n      const elements = document.querySelectorAll(selector)\r\n\r\n\r\n      elements.forEach(elem => {\r\n         elem.addEventListener('click', (e) => {\r\n            if (e.target.getAttribute('data-ratio')) {\r\n               ratio = +e.target.getAttribute('data-ratio');\r\n               localStorage.setItem('ratio', +e.target.getAttribute('data-ratio'));\r\n            } else {\r\n               sex = e.target.getAttribute('id');\r\n               localStorage.setItem('sex', e.target.getAttribute('id'));\r\n            }\r\n\r\n            elements.forEach(elem => {\r\n               elem.classList.remove(activeClass);\r\n            });\r\n\r\n            e.target.classList.add(activeClass);\r\n\r\n            calcTotal();\r\n         });\r\n      });\r\n   }\r\n   getStaticInformation('#gender div', 'calculating__choose-item_active');\r\n   getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n   function getDynamicInformation(selector) {\r\n      const input = document.querySelector(selector);\r\n\r\n      input.addEventListener('input', () => {\r\n\r\n         if (input.value.match(/\\D/g)) {\r\n            input.style.border = '1px solid red';\r\n         } else {\r\n            input.style.border = 'none';\r\n         }\r\n\r\n         switch (input.getAttribute('id')) {\r\n            case 'height':\r\n               height = +input.value;\r\n               break;\r\n            case 'weight':\r\n               weight = +input.value;\r\n               break;\r\n            case 'age':\r\n               age = +input.value;\r\n               break;\r\n         }\r\n\r\n         calcTotal();\r\n      });\r\n   }\r\n\r\n   getDynamicInformation('#height');\r\n   getDynamicInformation('#weight');\r\n   getDynamicInformation('#age');\r\n}\r\n\r\nmodule.exports = calc;","function cards() {\r\n   class MenuCard {\r\n      constructor(src, alt, title, descr, price, parentSelector) {\r\n         this.src = src;\r\n         this.alt = alt;\r\n         this.title = title;\r\n         this.descr = descr;\r\n         this.price = price;\r\n         this.parent = document.querySelector(parentSelector);\r\n         this.transfer = 27;\r\n         this.changeToUAH();\r\n      }\r\n\r\n      changeToUAH() {\r\n         this.price = this.price * this.transfer;\r\n      }\r\n\r\n      render() {\r\n         const element = document.createElement('div');\r\n         element.innerHTML = `\r\n         <div class=\"menu__item\">\r\n               <img src=${this.src} alt=${this.alt}>\r\n               <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n               <div class=\"menu__item-descr\">${this.descr}</div>\r\n               <div class=\"menu__item-divider\"></div>\r\n               <div class=\"menu__item-price\">\r\n                  <div class=\"menu__item-cost\">Цена:</div>\r\n                  <div class=\"menu__item-total\"><span>${this.price}</span> грн/день</div>\r\n               </div>\r\n            </div>\r\n         `;\r\n         this.parent.append(element);\r\n      }\r\n   }\r\n   // Для того чтобы использовать метод и объект на месте мы просто прописываем new MenuCard без присваивание к какойто переменнной\r\n   //   Мы создаем здесь объект сразу же на нем  вызываем метод render он что то сделает что то нам отработает со страницей и он исчезнет потому что больше на него не будет ссылок мы нигде не сохраняем этот объект, это удобно когда нам только один раз нужно его использовать\r\n\r\n   const getResource = async (url) => {\r\n      const res = await fetch(url);\r\n\r\n      if (!res.ok) {\r\n\r\n         //объект ошибки во внутрь мы помещяем текст ошибки который необходимо выдать \r\n         //Чтобы выкинуть эту ошибку нам понадобиться throw   = бросать  чтобы она выпала из нашей функции \r\n         throw new Error(`Could not fetch ${url}, status: ${res.status}`);\r\n      }\r\n\r\n      //транформирует этот ответ в Json\r\n      return await res.json(); // Пишем здесь return чтобы могли дальше по цепочке обработать и тут  мы должны дождатся результата этого промиса прежде чем его returnit\r\n   };\r\n\r\n   //Этот метод подходит когда мы работаем с шаблонизатором \r\n\r\n   getResource('http://localhost:3000/menu')\r\n      .then(data => {\r\n         data.forEach(({ img, altimg, title, descr, price }) => {\r\n            new MenuCard(img, altimg, title, descr, price, '.menu .container').render();\r\n         });\r\n      });\r\n\r\n\r\n\r\n   //axios.get('http://localhost:3000/menu')\r\n   //   .then(data => {\r\n   //      data.data.forEach(({ img, altimg, title, descr, price }) => {\r\n   //         new MenuCard(img, altimg, title, descr, price, '.menu .container').render();\r\n   //      });\r\n   //   });\r\n}\r\n\r\nmodule.exports = cards;","function forms() {\r\n   // Forms\r\n   // Реализация скрипта отправки данных на сервер\r\n\r\n\r\n   // Получаем все формы по тегу форм\r\n   const forms = document.querySelectorAll('form');\r\n   // Этот объект будет содержать список всех фраз которые я буду показывать в различных ситуациях \r\n   const message = {\r\n      //Чтобы использовать изображение из проекта необходимо лишь использовать пути к этим картинкам\r\n      loading: 'img/form/spinner.svg',\r\n      success: 'Спасибо скоро мы с вами свяжемся',\r\n      failure: 'Что-то пошло не так...',\r\n   }\r\n\r\n   //! Важный момент когда работаем на локальном сервере скорее всего после изменений каких то сбрасывать кэш, делается это для того чтобы изменения применились на странице потому что сервер запоминает старые изменения  чтобы каждый раз не подгружать и это наз-ся кэшом чтобы сбросит кэш Shift f5  \r\n\r\n   //Самое главное это взять все наши формы и под кажду из них подвязать postData подвязать \r\n\r\n   forms.forEach(item => {\r\n      //Сейчас на каждую форму будет подвязана функция postData который будет обработчиком события при отправке\r\n      bindPostData(item);\r\n   });\r\n\r\n   //Самое главное это взять все наши формы и под кажду из них подвязать postData подвязать \r\n\r\n   //Сейчас на каждую форму будет подвязана функция postData который будет обработчиком события при отправке\r\n   //Cоздаем функцию function Expression \r\n\r\n   // Наша функция postData занимается тем что она настраивает наш запрос она fetchit тоесть посылает наш запрос на сервер получает какой то ответ от сервера что например запостили успешно и после этого транформирует этот ответ в Json\r\n   const postData = async (url, data) => {\r\n      // создаем переменнную result  во внутрь нее мы  с вами будем помешать промис который возврашается от fetch \r\n      //когда мы делаем запрос мы сразу можем обработать те данные которые пришли \r\n\r\n      //она fetchit\r\n      const res = await fetch(url, {// это асинхронный код и он не ждет другой код  и Нам нужен механизм который превращяет ассинхронный код в синхронный для решения этой проблемы  появились такие операторы как Assync Await  \r\n         //await значит что неоьходимо дождаться результата этого запроса какой результат нас не волнует самое главное что мы должны его дождаться и толкьо после того как у нас будет результат await пропустит нас дальше \r\n         method: 'POST', //каким образом  \r\n         headers: {\r\n            'Content-type': 'application/json'\r\n         },\r\n         // и что имеено\r\n         body: data\r\n      });\r\n      //транформирует этот ответ в Json\r\n      return await res.json(); // Пишем здесь return чтобы могли дальше по цепочке обработать и тут  мы должны дождатся результата этого промиса прежде чем его returnit\r\n   }\r\n\r\n   // Функция которая будет отвечать за постинг даных\r\n   function bindPostData(form) {// эта функция будет принимать в себя какую то форму \r\n      // Используем аргумент форм потому что нам удобно бцдет навесить обработчик события\r\n      form.addEventListener('submit', (e) => { // и будем мы использовать событие submit оно срабатывает каждый раз когда мы пытаемся отправить какую то форму\r\n         //Чтобы отменить стандартное поведение браузера мы используем e.preventDefault\r\n         // Именно эта команда должна идти в самом начале чтобы не было проблем\r\n         e.preventDefault();\r\n\r\n         // Очень частый прием это создание нового блока на странице и туда мы выводим сообщение картинку не важно что самое главное что динамически будет появлятся какой то блок и чаще всего он добавляется к форме \r\n\r\n         //создаем div\r\n         const statusMessage = document.createElement('img');\r\n\r\n         //Добавляем классы в div \r\n         statusMessage.src = message.loading;\r\n         // Берем элемент и во внутрь помещаем то сообщение которое мы хотим показать \r\n\r\n         // Как только мы отправляем запрос  как только у нас произошел submit у нас самое главное сообщение это загрузка мы скажем пользователю что произошла загрузка  если у него медленный интернет он увидет это сообщение\r\n         statusMessage.style.cssText = `\r\n            display:block;\r\n            margin: 0 auto;\r\n         `;\r\n         // Главное не забыть отправить наш statusMessage куда то на страницу ведь  пока что он сущ лишь в JavaScripte \r\n         // form.append(statusMessage);\r\n\r\n         // Этот метод позволяет нам помещать наши элементы в разные места нашей верстки \r\n         form.insertAdjacentElement('afterend', statusMessage)\r\n         // Вместо XMLHttpReques работаем с fetch \r\n\r\n         //После этого Работаем с методом XMLHttpRequest() \r\n         //const request = new XMLHttpRequest();\r\n         // После этого  унас всегда вызывается метод open() чтобы настроить этот запрос\r\n         //request.open('POST', 'server.php');\r\n         // Следующая самая главная самая важная задача сделать так чтобы все данные которые заполнил пользователь в форме мы получили в JavaScripte и уже могли отправить на сервер\r\n         // Самый простой способ подготовить такие данные сформы это использовать объект который наз-ся formData \r\n         //нам не всегда нужно передавать в формате JSON\r\n         // Есть два формата первый это FormData второй это когда мы передаем JSON\r\n\r\n         // formData это специальный объект который позволяет с определенной формой быстро сформировать  все данные которые заполнил пользователь \r\n         //во внутрь мы помещаем форму из которой нам нужно собрать данные\r\n\r\n         //!Очень важный момент на котором можно запнуться и потерять много часов времени это касается того как сверстаны формы и как прописаны input если мы предпологаем что данные должны идти на сервер то в вертске внутри input всегда нужен атрибут \"name\" и главное чтобы знаения name они не повторялись и наче formData не сможет найти этот input не сможеть  взять из него данные value чтобы сформировать из него правтльный ответ\r\n         //! Всегда проверяйте name  у ваших form\r\n\r\n         //Настраиваем заголовки которые должны будут говорить серверу что именно приходит \r\n         // Чтобы правильно работать с FormData  во втром аргументе нам нужно указать multipart/form-data\r\n         //!Когда мы используем  свзяку XMLHttpRequest + form-data нам заголовок устанавливать не нужно  он утстанваливается автомотически  именно иза этой проблемы на сервере мы не получим данные\r\n         //request.setRequestHeader('Content-type', 'multipart/form-data');\r\n\r\n         //С каким форматом  мы будем общаться  JSON или form-data  зависит от бэкенда  \r\n         //request.setRequestHeader('Content-type', 'application/json');\r\n\r\n         //Задача у нас есть объект FormData которую на необходимо превратить в формат JSON\r\n         const formData = new FormData(form);\r\n\r\n         //FormData это довольно специфический объект и мы просто так его не можем прогнать в другой формат \r\n         // Для этого нам понадобиться прием который частенько используется\r\n         // Берем нашу formData которая собрала все данные с формы   ее сначала превращяеи в массив массивов после этого мы превращяем ее в классический объект а после этого мы этот классический объект превращяем в JSON \r\n         const json = JSON.stringify(Object.fromEntries(formData.entries())); // Метод entries возвращяет массив собственных перечисляемых свойтств у указанного объекта  массив массивов\r\n         // Теперь когда мы получили обычный объект а не FormData() мы на нем уже можем использовать конвертацию в JSON \r\n         //для этого создаем промежуточную переменнную используем JSON.stringify(внутрь помещаем object)которая превращает обычный объект в JSON  \r\n         //теперь все что надо сделать это взять JSON и поместить его в request.send(dvctnj formData json)\r\n         //const json = JSON.stringify(object);\r\n\r\n         // Отправляем данные используем метод send()\r\n         //request.send(json);//здесь уже есть body потому что мы что то отправляем\r\n         // Если внутри fetch promise попадает на ошибку котрая связана с http протоколом типо 404 502 тоесть мы сделали ошибку в названии url и тд он не выкинет reject это для него не считается ошибкой он нормально выполнит при этом reslolve самое главное для fetch  это то что он вообще смог сделать этот запрос и соответсвенно у нас reject будет возникать при сбое сети или если что то там помешало запросу  вообще выполнится у этого механизма есть свои плюсы мы еще разберем как обходить эту проблему и как выкидывать reject  даже если вдруг у нас что то пошло нет так \r\n\r\n         postData('http://localhost:3000/requests', json)\r\n            .then(data => {\r\n               console.log(data);//Data это просто те данные которые нам возврашяются из promise те которые нам вернул сервер  1 просто выведем в консоль то что нам вернул сервер \r\n               showThanksModal(message.success);//2  Запускаем функцию showThanksModal \r\n               form.reset(); // Мы сейчас поработаем и переместим ее кое куда в другое место \r\n               statusMessage.remove(); // Мы наш спиннер просто берем и удаляем, по факту это все действия которые нам сейчас нужны ,но если нам в будущем понадобиться в будущем еще расширить цепочку мы опять пропишем then  и выполним какую то операцию которая должна будет следовать строго за верхними командами \r\n\r\n            }).catch(() => {// Его желательно всегда прописывать в реальных проектах потому что нам все таки ошибки нужно обрабатывать\r\n               //Выполняем операцию которая соответсвует ошибке \r\n               // Если в результате моего запроса моего fetch возникнет какая то критическая ошибка например не туда послал запрос и тому подобное то у меня в методе catch выведется функция showThanksModal(message.failure); что то пошло не так и пожалуйста повторите немножко позже  \r\n               showThanksModal(message.failure);\r\n            }).finally(() => {//Используем его потому что у нас есть действие которое должно выполнится всегда у нас это очистка формы \r\n\r\n            })\r\n         // Когда данные уйдут на сервер нам с ними нужно будет что то сделать\r\n         // Отслеживаем конечную загрузку запроса\r\n         //request.addEventListener('load', () => {\r\n         // Если все правильно произошло \r\n         //   if (request.status === 200) {\r\n         //эта команда чтобы четко увидеть что все правильно произошло\r\n         //      console.log(request.response);\r\n         //Когда все успешно пришло выводим success тоесть у нас загрузка поменяется на success\r\n         //      showThanksModal(message.success);\r\n         //Очищаем нашу форму после успешной отправки \r\n         //      form.reset();\r\n         //      statusMessage.remove();\r\n         //   } else {\r\n         //      showThanksModal(message.failure);\r\n         //   }\r\n         //});\r\n      });\r\n   }\r\n   // Красивое оповещение пользователя\r\n   // функция которая тоже относиться к отправке формы\r\n   function showThanksModal(message) {\r\n      const prevModalDialog = document.querySelector('.modal__dialog');\r\n\r\n      prevModalDialog.classList.add('hide');\r\n      openModal();\r\n\r\n      const thanksModal = document.createElement('div');\r\n\r\n      thanksModal.classList.add('modal__dialog');\r\n      thanksModal.innerHTML = `\r\n         <div class=\"modal__content\">\r\n               <div class=\"modal__close\" data-close>×</div>\r\n               <div class=\"modal__title\">${message}</div>\r\n         </div>\r\n      `;\r\n\r\n      document.querySelector('.modal').append(thanksModal);\r\n      setTimeout(() => {\r\n         thanksModal.remove();\r\n         prevModalDialog.classList.add('show');\r\n         prevModalDialog.classList.remove('hide');\r\n         closeModal();\r\n      }, 4000);\r\n\r\n   }\r\n}\r\n\r\nmodule.exports = forms;","function modal() {\r\n   // Modal\r\n\r\n   const modalTrigger = document.querySelectorAll('[data-modal]'),\r\n      modal = document.querySelector('.modal');\r\n\r\n   modalTrigger.forEach(btn => {\r\n      btn.addEventListener('click', openModal);\r\n   });\r\n\r\n   function closeModal() {\r\n      modal.classList.add('hide');\r\n      modal.classList.remove('show');\r\n      document.body.style.overflow = '';\r\n   }\r\n\r\n   function openModal() {\r\n      modal.classList.add('show');\r\n      modal.classList.remove('hide');\r\n      document.body.style.overflow = 'hidden';\r\n      clearInterval(modalTimerId);\r\n   }\r\n\r\n   modal.addEventListener('click', (e) => {\r\n      if (e.target === modal || e.target.getAttribute('data-close') == \"\") {\r\n         closeModal();\r\n      }\r\n   });\r\n\r\n   document.addEventListener('keydown', (e) => {\r\n      if (e.code === \"Escape\" && modal.classList.contains('show')) {\r\n         closeModal();\r\n      }\r\n   });\r\n\r\n   const modalTimerId = setTimeout(openModal, 300000);\r\n   // Изменил значение, чтобы не отвлекало\r\n\r\n   function showModalByScroll() {\r\n      if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) {\r\n         openModal();\r\n         window.removeEventListener('scroll', showModalByScroll);\r\n      }\r\n   }\r\n   window.addEventListener('scroll', showModalByScroll);\r\n}\r\n\r\nmodule.exports = modal;","function slider() {\r\n   // Slider simple variant\r\n\r\n   //Берем класс который определяет каждый отдельный слайд\r\n   const slides = document.querySelectorAll('.offer__slide'),\r\n      //Получаем слайдер \r\n      slider = document.querySelector('.offer__slider'),\r\n      // Стрелочка prev \r\n      prev = document.querySelector('.offer__slider-prev'),\r\n      // Стрелочка next \r\n      next = document.querySelector('.offer__slider-next'),\r\n      total = document.querySelector('#total'),\r\n      current = document.querySelector('#current'),\r\n      slidesWrapper = document.querySelector('.offer__slider-wrapper'),\r\n      slidesField = document.querySelector('.offer__slider-inner'),\r\n      width = window.getComputedStyle(slidesWrapper).width;\r\n\r\n\r\n   // Индекс которая будет определять текущее положение в слайдере \r\n   let slideIndex = 1;\r\n   let offset = 0;\r\n\r\n   if (slides.length < 10) {\r\n      total.textContent = `0${slides.length}`;\r\n      current.textContent = `0${slideIndex}`;\r\n   } else {\r\n      total.textContent = slides.length;\r\n      current.textContent = slideIndex;\r\n   }\r\n\r\n   // Устанавливаем этому блоку ширину \r\n   slidesField.style.width = 100 * slides.length + '%';\r\n   slidesField.style.display = 'flex';\r\n   slidesField.style.transition = '0.5s all';\r\n\r\n   slidesWrapper.style.overflow = 'hidden';\r\n\r\n\r\n   slides.forEach(slide => {\r\n      slide.style.width = width;\r\n   });\r\n\r\n   slider.style.position = 'relative'\r\n\r\n   //  Создаем большую обертку для наших точек  как то их стилизуем \r\n   const indicators = document.createElement('ol'),\r\n      dots = [];\r\n\r\n   indicators.classList.add('carousel-indicators');\r\n   indicators.style.cssText = `\r\n      position: absolute;\r\n      right: 0;\r\n      bottom: 0;\r\n      left: 0;\r\n      z-index: 15;\r\n      display: flex;\r\n      justify-content: center;\r\n      margin-right: 15%;\r\n      margin-left: 15%;\r\n      list-style: none;\r\n   `;\r\n   slider.append(indicators);\r\n\r\n   for (let i = 0; i < slides.length; i++) {\r\n      const dot = document.createElement('li');\r\n      dot.setAttribute('data-slide-to', i + 1);\r\n      dot.style.cssText = `\r\n         box-sizing: content-box;\r\n         flex: 0 1 auto;\r\n         width: 30px;\r\n         height: 6px;\r\n         margin-right: 3px;\r\n         margin-left: 3px;\r\n         cursor: pointer;\r\n         background-color: #fff;\r\n         background-clip: padding-box;\r\n         border-top: 10px solid transparent;\r\n         border-bottom: 10px solid transparent;\r\n         opacity: .5;\r\n         transition: opacity .6s ease;\r\n      `;\r\n\r\n      if (i == 0) {\r\n         dot.style.opacity = 1;\r\n      }\r\n      indicators.append(dot);\r\n      dots.push(dot);\r\n   }\r\n\r\n   function deleteNotDigits(str) {\r\n      return +str.replace(/\\D/g, '');\r\n   }\r\n\r\n   // Обработчик события для того чтобы передвигать наш слайдер \r\n   next.addEventListener('click', () => {\r\n      if (offset == deleteNotDigits(width) * (slides.length - 1)) { //'500px'\r\n         offset = 0;\r\n      } else {\r\n         offset += deleteNotDigits(width);\r\n      }\r\n      slidesField.style.transform = `translateX(-${offset}px)`;\r\n\r\n      if (slideIndex == slides.length) {\r\n         slideIndex = 1;\r\n      } else {\r\n         slideIndex++\r\n      }\r\n\r\n      if (slides.length < 10) {\r\n         current.textContent = `0${slideIndex}`;\r\n      } else {\r\n         current.textContent = slideIndex;\r\n      }\r\n\r\n      dots.forEach(dot => dot.style.opacity = '.5');\r\n      dots[slideIndex - 1].style.opacity = 1;\r\n   });\r\n\r\n   //Обработчик события для того чтобы передвигать наш слайдер назад\r\n   prev.addEventListener('click', () => {\r\n      if (offset == 0) { //'500px'\r\n         offset = deleteNotDigits(width) * (slides.length - 1)\r\n      } else {\r\n         offset -= deleteNotDigits(width);\r\n      }\r\n      slidesField.style.transform = `translateX(-${offset}px)`;\r\n\r\n      if (slideIndex == 1) {\r\n         slideIndex = slides.length;\r\n      } else {\r\n         slideIndex--;\r\n      }\r\n\r\n      if (slides.length < 10) {\r\n         current.textContent = `0${slideIndex}`;\r\n      } else {\r\n         current.textContent = slideIndex;\r\n      }\r\n      dots.forEach(dot => dot.style.opacity = '.5');\r\n      dots[slideIndex - 1].style.opacity = 1;\r\n   });\r\n\r\n   dots.forEach(dot => {\r\n      dot.addEventListener('click', (e) => {\r\n         const slideTo = e.target.getAttribute('data-slide-to');\r\n\r\n         slideIndex = slideTo;\r\n         offset = deleteNotDigits(width) * (slideTo - 1);\r\n\r\n         slidesField.style.transform = `translateX(-${offset}px)`;\r\n\r\n         if (slides.length < 10) {\r\n            current.textContent = `0${slideIndex}`;\r\n         } else {\r\n            current.textContent = slideIndex;\r\n         }\r\n         dots.forEach(dot => dot.style.opacity = '.5');\r\n         dots[slideIndex - 1].style.opacity = 1;\r\n      });\r\n   });\r\n}\r\n\r\nmodule.exports = slider;","function tabs() {\r\n   const tabs = document.querySelectorAll('.tabheader__item'),\r\n      tabsContent = document.querySelectorAll('.tabcontent'),\r\n      tabsParent = document.querySelector('.tabheader__items');\r\n\r\n   function hideTabContent() {\r\n      tabsContent.forEach(item => {\r\n         item.classList.add('hide');\r\n         item.classList.remove('show', 'fade');\r\n      });\r\n\r\n      tabs.forEach(item => {\r\n         item.classList.remove('tabheader__item_active');\r\n      });\r\n   }\r\n\r\n   //Если функция вызывается без аргумента  то по уолчанию отработает то что присвоили  i \r\n   function showTabContent(i = 0) {\r\n      tabsContent[i].classList.add('show', 'fade');\r\n      tabsContent[i].classList.remove('hide');\r\n      tabs[i].classList.add('tabheader__item_active');\r\n   }\r\n\r\n\r\n   hideTabContent();\r\n   showTabContent();\r\n\r\n   tabsParent.addEventListener('click', (event) => {\r\n      const target = event.target;\r\n\r\n      if (target && target.classList.contains('tabheader__item')) {\r\n         tabs.forEach((item, i) => {\r\n            if (target == item) {\r\n               hideTabContent();\r\n               showTabContent(i);\r\n            }\r\n         });\r\n      }\r\n   });\r\n}\r\n\r\nmodule.exports = tabs;","function timer() {\r\n   // Timer\r\n\r\n   const deadline = '2023-08.24';\r\n\r\n   // задачаа нашей функции это получить разницу между датами\r\n   function getTimeRemaining(endtime) {\r\n      let days, hours, minutes, seconds;\r\n      const t = Date.parse(endtime) - Date.parse(new Date());\r\n      if (t <= 0) {\r\n         days = 0;\r\n         hours = 0;\r\n         minutes = 0;\r\n         seconds = 0;\r\n      } else {\r\n         days = Math.floor(t / (1000 * 60 * 60 * 24)),\r\n            hours = Math.floor((t / (1000 * 60 * 60) % 24)),\r\n            minutes = Math.floor((t / 1000 / 60) % 60),\r\n            seconds = Math.floor((t / 1000) % 60);\r\n      }\r\n\r\n      return {\r\n         'total': t,\r\n         'days': days,\r\n         'hours': hours,\r\n         'minutes': minutes,\r\n         'seconds': seconds,\r\n      };\r\n\r\n   }\r\n\r\n   function getZero(num) {\r\n      if (num >= 0 && num < 10) {\r\n         return `0${num}`;\r\n      } else {\r\n         return num;\r\n      }\r\n   }\r\n\r\n\r\n   // Функция которая будет устонавливать timer на страничку\r\n   function setClock(selector, endtime) {\r\n      const timer = document.querySelector(selector),\r\n         days = timer.querySelector('#days'),\r\n         hours = timer.querySelector('#hours'),\r\n         minutes = timer.querySelector('#minutes'),\r\n         seconds = timer.querySelector('#seconds'),\r\n         timeInterval = setInterval(updateClock, 1000);\r\n\r\n\r\n\r\n      updateClock();\r\n\r\n      // Функция которая будет обновлять наш Timer Каждую секунду\r\n      function updateClock() {\r\n         const t = getTimeRemaining(endtime);\r\n\r\n         days.innerHTML = getZero(t.days);\r\n         hours.innerHTML = getZero(t.hours);\r\n         minutes.innerHTML = getZero(t.minutes);\r\n         seconds.innerHTML = getZero(t.seconds);\r\n\r\n         if (t.total <= 0) {\r\n            clearInterval(timeInterval);\r\n         }\r\n      }\r\n   }\r\n\r\n   setClock('.timer', deadline);\r\n\r\n   // Modal\r\n   const modalTrigger = document.querySelectorAll('[data-modal]'),\r\n      modal = document.querySelector('.modal');\r\n   //modalContent = document.querySelector('.modal__content'),\r\n\r\n\r\n   //Вариант Ивана Петреченко\r\n   function openModal() {\r\n      modal.classList.add('show');\r\n      modal.classList.remove('hide');\r\n      document.body.style.overflow = 'hidden';\r\n      clearInterval(modalTimerId);\r\n\r\n   }\r\n   modalTrigger.forEach(btn => {\r\n      btn.addEventListener('click', openModal);\r\n   });\r\n\r\n   function closeModal() {\r\n      modal.classList.add('hide');\r\n      modal.classList.remove('show');\r\n      document.body.style.overflow = '';\r\n   }\r\n\r\n\r\n\r\n   modal.addEventListener('click', (e) => {\r\n      if (e.target === modal || e.target.getAttribute('data-close') == '') {\r\n         closeModal();\r\n      }\r\n   });\r\n\r\n   document.addEventListener('keydown', (e) => {\r\n      if (e.code === 'Escape' && modal.classList.contains('show')) {\r\n         closeModal();\r\n      }\r\n   });\r\n\r\n\r\n\r\n   const modalTimerId = setTimeout(openModal, 50000);\r\n\r\n   function showModalByScroll() {\r\n      if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1) {\r\n         openModal();\r\n         window.removeEventListener('scroll', showModalByScroll);\r\n      }\r\n   }\r\n\r\n   window.addEventListener('scroll', showModalByScroll);\r\n\r\n}\r\n\r\nmodule.exports = timer;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\"\n\nwindow.addEventListener('DOMContentLoaded', () => {\n   // Объединяем все файлы заимпортировав их в главный\n   // Порядок подключения абсолютно не важен\n   const tabs = require('./modules/tabs'),\n      modal = require('./modules/modal'),\n      timer = require('./modules/timer'),\n      cards = require('./modules/cards'),\n      calc = require('./modules/calc'),\n      forms = require('./modules/forms'),\n      slider = require('./modules/slider');\n\n   // раз это функции нам их необходимо вызвать\n   tabs();\n   modal();\n   timer();\n   cards();\n   calc();\n   forms();\n   slider();\n});\n\n\n"],"names":[],"sourceRoot":""}