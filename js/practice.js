'use strict';

// Event loop, подробная работа асинхронных и синхронных операций

// Здесь самое главное разобраться с таким понятием как event loop или событийный цикл

// Эту информацию очень часто справшивают на собеседованиях 

// Комбиниируем синхронный и ассинхронный код 
console.log(1);

setTimeout(() => {
   console.log('timeout');
}, 2000);//эта команда у нас принимает как первый оюъект функцию которая будет запускаться


setTimeout(() => {
   console.log('timeout_4000');
}, 4000);

console.log(2);
// Выведется 1,2, timeout,timeout_4000

//В реальном коде у нас постоянно будут работать комбинации как синхронного так и асинхронного кода

// Ассинхронными являются операции которые запускаются с тчением определенного  времени  это setTimeout setInterval кроме этого это могут быть абсолютно любые запросы на сервер это происходит по той причине что мы абсолютно не уверены через сколько нам ответит сервер поэтому данные операции запускаются ассинхронно и абсолютно не мешают другому коду который работает в нашем приложении

// Если капнуть еще в глубь то все callbackи которые мы используем являются асснихронными когда мы прописываем обработчик события клика лиюо мы отслеживаем событие скролла либо используем событие submit для того чтобы отправить форму на сайт все эти операции происходят ассинхронно

// Call Stack это те операции тоесть вызовы функций которые выполняются в данный момент с таким понятием мы уже сталкивались когда разбирали консоль разработчика и там мы моглы прямо найти такое понятие как call stack тоесть какие вызовы привели к данному результату здесь это очень похожая ситуация

// Web Apis  это специальное хранилище которое есть в браузере для того чтобы хранить какие то ваши промежуточые данные, Например: когда вы запускаете setTimeout у вас где то должно записываться что вот такая вот функция должна выполнится через определенное кол-во времени, соответсвенно этот контейнер служит для того чтобы запоминать такую инфрмацию и он может хранить в себе очень много всего

// Callback Queue - все опреации которые выолняются в браузере они на самом деле становятся  в какую то очередь, паралельно они выполнятся не могут и соответственно сюда у нас приходят различные события различные функции и просто становятся в очередь выполнилось первая за ним начинает выполнятся следующая  по факту это уже и есть событийный цикл

// Навешивание обработчика это синхронный код

// Все наши действия которые происходят на странице клики какие то обработчики событий callback функции все они становятся в очередь, они не могут одновременнно все выполнятся да конечно ща счет того что ваш браузер и компьютер работает очень быстро вы этого не замечаете но все действия именноо таки работают в них есть событийный цикл по которому и происходят все действия в браузере

// Вывод если у вас на странице есть какая то очень таяжелая задача которая работает внутри цикла или внутри перебирающего метода то она может полностью остановить работу вашей страницы и именно потому что в callstack зависает определенная задача  у вас весь calback queue они будут оставться они не будут никак выполнятся

// Будьте очень аккуратны в будущем когда вы запускаете очень сложные скрипты на своей странице они действительно могут убить вашу вкладку для решения таких  сложных задач  есть небольшие patterny  вы просто берете  тяжелую задачу и разбиваете ее на кусочки 

setTimeout(() => {
   console.log(1);
}, 0);

console.log(2); 
// выведется 2 потом 1 

// Здесь два объяснения этому поведению 
//во первых это чисто програмное дело в том что когда вы запускаете setTimeout щн всет равно проходит через ассинхронную часть тоесть он попадает в Web Apis  и здесь сначала записывается и после этого идет в callback Queue если эта операция в любом случае будет ассинхронная то сначала выполнится синхронный код который выполнится дальше именно так вы и должны отвечать 

// Вторая часть дело в том что когда JavaScript видит 0 либо какое то значение 1 два три то он  автоматически подставляет 4 миллисекунды сделано это для совместимости между разными браузерами ведь мы совершенно не можем предугадать как разные браузеры будут обрабатывать когда мы потавим 0 поэтому по умолчанию JS сюда ставит 4 миллисекунды чтобы хоть какая то минимальная задержка была 

// В практике вы частенько можете встретить такой небольшой костыль когда используют setTimeout  с нулем 0 для того чтобы  выполнить определенные  операции после ассинхронного кода 

// Допустим у вас есть какая то синхронная операцию по формированию элементов  на странице  и вот из этих сформированных элементов нам необходимо получить определенные параметры например ширину которая уже сформировалась на странице тоесть ComputedStyle и в некоторых случаях для того чтобы четко сформировать порядок то что сначало у нас формируется структура после этого мы уже должны получить со сформированной структуры определенные значения  и используется setTimeout с нулем 0

// Потому что наш асснихронный код будет выполнятся  всегда после синхронного  самое главное если вы понимаете как работает такой код то у вас не будет проблем не при общении с сервером  не при формировании таких ассинхронных структур 

