"use strict"

//Регулярные выражения

// Если говорить о назначении зачем нам это вообще нужно то такая технология позволяет нам очень удоьно работать со  строками  Удалять заменять какие то части слов искать какие кусочки строк  ограничивать ввод определенных знаков и многое многое другое

// Вообще если говорить в целом такая технолония работает  не только в JavaScript она используется повсеместно  в других языках програмирования в других технолониях и тп но знать хотябы основы этой технологии нам необходимо потому что она очень часто используется в скриптах 

// Любое регулярное выражение состоит из двух частей первое это паттер второе это флаги 
// Паттерн это по другому шаблон это шаблон того что мы ищем в этой строке или что мы пытаемся удалить и тому подобное тоесть как то мы ограничиваем список символов или их порядок 

// В JavaScript для то чтобы создать регулярные выражения мы можем  воспользоваться несколькими синтаксисами самый первый вариант это при помощи конструктора мы можем создать new RegExp()
// Вот это классический синтаксис для создания регулярных выражений которым никто не пользуется 
//new RegExp('patter', 'flags');

// Почему потому что у нас есть более короткий синтаксис 
// В скриптах в 99% случаев мы будем встречать именно этот синтаксис 
///pattern/f

// Самый первый метод search этот метод у нас пытается что то найти 
//В это строке  нужной найти все буквы н
//const ans = prompt('Введите ваше имя');

//const reg = /n/ig;
//классические флаги
// 1 i если мы хотим что то найти вне зависимости от регистра
// 2 g -global это когда мы пытаемся найти сразу несколько вхождений
// 3 m  он включает у нас многочтрочный режим  ведь строки у нас могут находится и  с переносами 
// Эти флаги можно комбинировать например /n/igm /n/gim


// Это все методы которые относятся к строкам

// Метод search всегда ищет только первое совпадение 
//console.log(ans.search(reg));

// Метод match 
// Когда мы используем match мы получаем массив в котором у нас есть во первых тот кусочек строки в котором мы искали потом индекс в котором он был найден и непосредственно сама строка в которой был совершен поиск
// Свойство match уже мощнее здесь мы можем использовать уже какие то свойтсва из этого массива если вдруг они нам понадобятся  

// Если у нас сработает флаг глобальности в таком случае то мы получаем массив со всеми найденными результатами 
// Так что если нас интерисует все найденные такие элементы по определенному шаблону то нам нужно будет использовать match
//console.log(ans.match(reg));

// След этапом  у нас будет метод replace() который позволяет нам брать какой то кусочек строки  и заменять его на другое выражение 

//const pass = prompt('Password');

// Этот метод принимает в себя два аргумента первый метод это что мы заменяем второй метод это на что мы заменяем
// Мы можем создавать регулярные выражения прямо внутри аргумента тоесть нам необязательно делать это в отдельной переменнной
//console.log(pass.replace(/\./g, "*"));
// этот символ значит \ экранирование
//В регулярных  выражениях есть свои правила если внутри нее мы ставим . точку  это значит что мы берем обсалютно  все элементы которые попадут в строку, здесь можно приветси аналогию с универсальным селектором * в css здесь это работает точно также, поэтому мы берем  абсолютно все символы которые будут нашем пароле и заменяем их просто на * зведочку, причем с флагом глобальности g чтобы взять действительно все символы


// В регулярке довольно много спец символов если мы внутри хотим найти вот такой слеш то мы его должны экранировать точно таким же слешом //

// Модифицируем эту строки прямо здесь на месте и сказать надо коду что мы хотим убрать все дефизы -
// Особенно это приятно использовать в часах которые нужно модифицировать 
// Здесь все дефизы поменяются на двоеточия
//console.log('12-34-56'.replace(/-/g, ':'));

// Это были самые известные самые попклярнве методы которые были у строк но на самом деле  у регулярных выражений как у объекта у него есть и свои методы 

//например метод тест

//const ans = prompt('Введите ваше число');
//const reg = /\d/g;

// Важной особенностью этого метода является в том что он нам вернет либо false либо true 
// Если у нас совпадение то true если нет тогда false 
// Если напишем что то содержащее буковку n нам вернется true если нет false
//console.log(ans.match(reg))

// В регулярных выржениях есть такое понятие как классы

// Первый и самый популярный класс digits для этого мы пишем обратный слэш и d так \d мы с вами ищем цифры
// \w  это значит что мы ищем все слова все буквы
// \s мы можем искать пробелы  кстати пробел это тоже отдельный символ который мы можем искать  внутри регулярного выражения если мы вмсето с просто поставим пробел то мы будем искать пробелы / /так мы можем тоже искать пробелы

// Эти классы тоже можно комбинировать состовляя более сложные конструкции 

const str = 'My name is R2D2';
// И здесь наша задача это вырезать вот это вот имя 

console.log(str.match(/\w\d\w\d/i))


//Обратные классы тоесть не числа не классы не строки они пишутся точно также но с большой буквы
//\D
//\W
//\S

//Ищем все кроме букв 
console.log(str.match(/\W/ig))
//Ищем все кроме цифр 
console.log(str.match(/\D/ig))
//Ищем все кроме пробелов
console.log(str.match(/\S/ig))